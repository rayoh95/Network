### 네트워크

<hr>



가까이에 있는 컴퓨터끼리(LAN 대역) 어떻게 통신하는가 => `OSI 7계층 중 2계층의 역할`



#### 2 계층에서 하는 일

하나의 네트워크 대역 즉, `같은 네트워크` 상에 존재하는 여러 장비들 중에서 `어떤 장비`가 `어떤 장비`에게 보내는 데이터를 전달.

추가적으로 오류제어, 흐름제어 수행

* 하나의 네트워크 대역 `LAN 에서만` 통신할 때 사용.
* 다른 네트워크와 통신할 때는 항상 3계층이 도와주어야 한다.



#### 2 계층에서 사용하는 주소 : `MAC 주소`

MAC 주소 (물리적인 주소) -> cmd 에서 확인 가능.

16진수 사용	->	ex) 6C-29-95-04-EB-A1 : 총 6 byte (16진수 하나 당 4bit = 0.5byte)

`OUI` : MAC 주소 앞의 6자리. 네트워크 장치의 MAC 주소를 부여한 회사의 고유 번호 (뒤의 나머지 6자리 수는 제조사에서 부여한 장비의 고유번호)

하드웨어 장치에 부여되는 번호이므로 쉽게 바꿀 수 없다.



#### `2계층의 프로토콜 (Ethernet 프로토콜)`

* 목적지의 주소가 먼저 오고, 후에 출발지 주소가 온다. (Ethernet 의 특징)

`Destination Address` | `Source Address` | `Ethernet Type` : 총 14 byte

Destination Address : 목적지 MAC 주소 (6 byte)

Source Address : 출발지 MAC 주소 (6 byte)

Ethernet Type : 2 byte. 실상은 프로토콜의 타입. 페이로드 안에 상위(3계층) 프로토콜이 들어있다. 그 상위 프로토콜을 미리 알려주는 것. Decapsulation 시 분석이 수원해진다. Ethernet 프로토콜의 상위 계층으로 올 수 있는 프로토콜은 IPv4 와 arp 이다. 만약 상위 프로토콜이 IPv4 라면, Ethernet Type 에는 16진수로 Ox0800 이 온다. 만일 상위 프로토콜이 arp 라면, Ox0806 이 온다. 



##### MAC 주소 확인하기

cmd 창에 `ipconfig /all` 입력 -> 물리적 주소를 찾을 수 있다.



<hr>



#### 3 계층의 기능

`서로 다른 네트워크(LAN)` 대역 즉, 멀리 떨어진 곳에 존재하는 네트워크까지 어떻게 데이터를 전달할지 제어하는 일을 담당.

발신에서 착신까지의 패킷의 `경로`를 제어

LAN 끼리의 통신을 위해서는 `라우터`와 같은 3 계층 장비가 필요하다. 스위치라는 2 계층 장비만으로는 서로 다른 네트워크 대역을 만들 수 없다.



#### 3 계층에서 스는 주소 : IP 주소

`IPv4 주소` : 현재 PC에 할당된 IP 주소. 보통 우리가 말하는 IP 주소가 바로 IPv4 주소이다.

`서브넷 마스크` : IP 주소에 대한 네트워크의 대역을 규정하는 것

`게이트웨이 주소` : 외부와 통신할 때 사용하는 네트워크 출입구



#### IP 주소의 변화 (어떻게 부족 현상을 해결했는가)



##### 1. 맨 처음 만든 IP 주소는 Classful IP 주소 이다. 이 주소는 낭비가 심하다. (사용할 수 있는 범위가 정해져 있다.)

IP 주소는 필드가 4개로 이루어져 있고 '.' 으로 구분한다. ex) 192.168.0.189

IP 주소는 4 byte 이며 10진수로 표기한다. (각 1 byte 의 범위는 0 ~ 255 이다.)

이 범위를 각 Class 별로 나누어 사용하던 것이 초창기 Classful IP 주소이다.



* Class A	:	0.......	.......	.......	.......		`First byte`: 0 to 127					0.0.0.0 ~ 127.255.255.255
* Class B	:	10......	.......	.......	.......		`First byte`: 128 to 191              128.0.0.0 ~ 191.255.255.255
* Class C	:	110.....	.......	.......	.......		`First byte`: 192 to 223            192.0.0.0 ~ 223.255.255.255
* Class D	:	1110....	.......	.......	.......		`First byte`: 224 to 239           224.0.0.0 ~ 239.255.255.255
* Class E	:	1111....	.......	.......	.......		`First byte`: 240 to 255            240.0.0.0 ~ 255.255.255.255

첫 번째 바이트는 네트워크 대역을 결정한다.



##### 2. 낭비되지 않도록 아껴쓰는 `Classless IP 주소`.  현재에 쓰이는 주소 -> 원하는 곳(32 곳) 어디서든 잘라서 쓰자.

`서브넷 마스크` 

* 네트워크 대역을 어디서부터 구분할 것인지 나눠주는데 사용하는 값 (Classful IP 주소처럼 무조건 1 바이트로 구분하지 않는다.)

* 2진수로 표기했을 때 무조건 1로 시작, 1과 1 사이에는 0이 올 수 없다는 규칙을 가지고 있다. -> 연속된 1로 이루어져 있으며, 0이 한 번 나오면 그 뒤에는 전부 0 이다.
* 즉, 1이 0으로 바뀌는 지점이 네트워크를 구분하는 지점이다.

Ex ) 255.255.255.192  ->  11111111. 11111111. 11111111. 11000000



##### 3. 사설 IP 와 공인 IP. 현재 사용하고 있는 IPv4 의 개념이다. 정확히는 Classless 와 함께 쓰고있다.

`공인 IP` : 실제 인터넷(네트워크 통신망)이랑 통신할 때 사용하는 IP 주소

`사설 IP` : 같은 네트워크 대역에서 사용하는 IP 주소

사설 IP 를 사용하는 장비들이 네트워크 통신을 할 때, 무조건 공인 IP 하나로 바꾸어 외부 네트워크와 통신한다. -> 네이버 검색창에 '내 IP' 검색하면 같은 네트워크를 쓰는 컴퓨터는 모두 같은 IP 주소가 검색된다. -> 공인 IP 주소가 검색된 것

##### `NAT(Network Address Translation)`

* 네트워크 주소를 사설 IP 에서 공인 IP 로 바꾸어 주는 것. (엄밀하게는 특정 IP 를 특정 IP 로 바꾸는 기술이다. 이 기술을 이용해 IP 부족 현상을 해결하기 위해 사설 IP 와 공인 IP 의 전환으로 사용.)

`NAT Table`

* 요청 시 사설 IP 가 공인 IP 로 전환될 때, 그 기록을 담아두는 곳. 응답 시 NAT Table 을 통해 정확한 사설 IP 주소를 찾아가 응답해준다.



#### 특수한 IP 주소

1. `0.0.0.0`
   * `나머지` 모든 IP. 일반적인 IP 주소가 아니다
2. `127.0.0.1`
   * 나 자신을 나타내는 주소. (127 로 시작하는 주소들)
3. `게이트웨이 주소`
   * 일반적으로 공유기의 IP(즉, 공인 IP). 보통 해당 네트워크 대역에서 쓸 수 있는 IP 중 가장 낮은 번호나 높은 번호를 쓴다.
   * 외부 네트워크로 나가는 문이 어디인지 알려준다고 생각하자.





#### 3 계층 프로토콜



#### `1. ARP 프로토콜`

`ARP 프로토콜`은 `같은 네트워크 대역`에서 통신을 하기 위해 필요한 MAC 주소를 IP 주소를 이용해서 알아오는 프로토콜이다. (사람들은 MAC 주소를 이용하기 보다는 IP 주소를 이용해서 접근하기 때문에)

같은 네트워크 대역에서 통신을 한다고 하더라도 데이터를 보내기 위해서는 7계층부터 캡슐화를 통해 데이터를 보내기 때문에 IP 주소와 MAC 주소가 모두 필요하다. 이 때, IP 주소는 알고 MAC 주소는 모르더라도 ARP 를 통해 통신이 가능하다.



##### `ARP 프로토콜의 구조`

총 28 byte. (4 byte 씩 7층)

* Hardware type = 2 계층에서 사용하는 프로토콜(ex. Ethernet : 0001) : 4 byte
* Protocol type = 3 계층에서 쓰는 프로토콜(ex. IPv4 : 0800) : 4 byte
* Hardware Address Length = MAC 주소의 길이.크기는 6 byte 이므로 06 이라는 데이터가 붙는다 : 2 byte
* Protocol Address Length = IP 주소의 길이.크기는 4 byte 이므로 04 이라는 데이터가 붙는다 : 2 byte
* Opcode(Operation Code) = 어떻게 동작하는지 나타내는 코드 값. 2 종류 뿐이다 -> ARP 프로토콜로 상대방의 맥 주소를 요청하는 것 인지(0001), 응답하는 것 인지(0002) 나타내는 값 : 4 byte

* 출발지의 맥 주소(Sourcd Hardware Address) : 6 byte
* 출발지의 IP 주소(Source Protocol Address) = `IPv4` : 4 byte
* 목적지의 맥 주소(Destination Hardware Address): 6 byte
* 목적지의 IP 주소(Destination Protocol Address) : 4 byte



#### IP 주소로 MAC 주소를 알아오는 과정

같은 네트워크 대역에 있는 컴퓨터들이 존재한다. 그 중 컴퓨터 한 대가 특정 컴퓨터와 데이터를 주고받으려고 한다. 이 때, 목적지 컴퓨터의 IP 주소는 알지만 MAC 주소는 모르는 상태.

1. 출발지인 컴퓨터에서 요청을 보낼 패킷을 만든다.

패킷의 형태 : `Eth` | `ARP 요청`

이 때,  ARP 요청의 구조 : 01 01 | 08 00

​									   06 04 | 00 01

​								 	  출발지 맥 주소

​									   출발지 IP 주소

​									   목적지 맥 주소 (모르기 때문에 전부 0 으로 채운다 : 00 00 00 00 00 00)

​									   목적지 IP 주소

이 때, Ethernet 프로토콜의 구조 : 목적지의 맥 주소 (모르기 때문에 F로 채운다 : FF FF FF FF FF FF) -> 2 진수로 치면 1 로 꽉 채운 것. IP 주소에서 뒷 부분을 1 로 꽉 채우면 `BroadCast 주소`가 된다. 이는 MAC 주소도 마찬가지. BroadCast 로 같은 네트워크 대역에 있는 모든 컴퓨터에게 이 요청을 보낸다는 의미이다.

​													 출발지의 맥 주소

​													 08 06

2. 이 패킷을 2계층 장비인 스위치를에게 전달한다. 스위치는 2계층 장비이므로 2 계층 프로토콜인 Ethernet 프로토콜을 확인(Decapsulation)한다.
3. 목적지 MAC 주소가 BroadCast 이므로 이 패킷을 모든 컴퓨터에게 보낸다.
4. 패킷을 받은 모든 컴퓨터는 Ethernet 프로토콜을 확인하고, BroadCast 임을 확인. 나한테 온 패킷인지 확인하는 과정.
5. 3 계층도 확인한다.
6. 모든 컴퓨터 중 패킷의 목적지 IP 주소가 일치하는 컴퓨터는 그대로 응답 프로토콜을 만들어서 준다. 당연히 목적지 주소랑 출발지 주소를 채워서 응답한다. 
7. 처음 요청을 보낸 컴퓨터는 응답을 받고 상대 컴퓨터의 MAC 주소를 확인 후, `ARP 캐시 테이블`을 작성한다.
8. 이후 통신 시작





#### `2. IPv4 프로토콜` 

네트워크 상에서 `서로 다른 네트워크`가 데이터를 교환하기 위한 프로토콜 -> `WAN`

데이터를 보내기는 하지만, `정확하게 전달될 것을 보장하지 못한다.` -> 라우팅 역할만 하는 것이다.

중복된 패킷을 전달하거나 패킷의 순서를 잘못 전달할 가능성도 있다. (악의적으로 이용되면 DoS 공격이 됨)

데이터의 정확하고 순차적인 전달은 그보다 상위 프로토콜인 TCP 에서 보장한다. -> 신뢰성의 역할



##### `IPv4 프로토콜의 구조`

총 20 byte (4 byte 씩 5층)

* 버전(Versino) = IP 프로토콜의 버전 데이터인데, 그냥 4 라고 생각하면 된다 : 4 bit
* IHL(IP Header Length) = 헤더의 길이 = IPv4 프로토콜의 길이는 최소 20 byte, 옵션이 붙으면 최대 60 byte 까지 커진다. 그 길이를 4로 나눈 값을 표현 : 4 bit
* Type of Service(TOS) = 현재는 쓰이지 않는 값. 0 으로 비워둔다 : 1 byte
* Total Length = 헤더의 길이를 얘기하는 것이 아닌, 상위 계층에서부터 캡슐화 되어 내려온 뒤의 페이로드까지 합한 길이 : 2 byte
* Identification + IP Flags + Fragment Offset = 데이터가 큰 것을 보낼 때, 최대 전송 단위가 존재하기 때문에 데이터를 잘라서 전송하는데, 그 데이터를 확인하는데 사용되는 값들이다 : 2 byte
  * Identification = 잘라진 데이터가 원래는 하나의 데이터였음을 인증하기 위해 id 를 부여한다 : 2 byte
  * IP Flags = 3 bit 로 이루어져 있다. 첫 번째 비트는 쓰지 않는 데이터로 x 로 전달. 두 번째 비트는 D 로 Don't Fragmentation, 이 데이터가 1 이면 패킷을 보내는 컴퓨터가 데이터를 쪼개지 않고 보내겠다고 명시하는 것이다. 즉, 안쓰는 데이터(0). 세 번째는 M 으로 More Fragmentation, 뒤에 패킷들이 더 존재한다는 의미로 1 의 데이터가, 없다면 0 의 데이터가 들어간다.  
  * Fragment Offset = 조각난 데이터들의 순서를 조립(데이터의 크기 / 8 의 값) : 13 bit
    * Offset 은 시작점부터 얼마나 떨어져 있는가로 데이터의 순서를 정한다. 맨 앞의 데이터는 0, 그 뒤의 데이터는 앞의 데이터의 크기 값, 그 뒤 데이터는 앞에있는 데이터들의 크기의 합...
* Time To Live(TTL) = 패킷의 유효기간을 설정. 3계층에서는 데이터 전달의 신뢰성이 보장되지 않는다. 혹시 데이터가 목적지에 도달하지 못하고 네트워크 상에서 떠돌아다닐 경우 데이터를 폐기하기 위해 설정된 값 : 1 byte
* Protocol : Ethernet type 과 같은 역할. 상위 프로토콜의 정보를 알려준다(ICMP , TCP, UDP) : 1 byte
* Header Checksum : 헤더에 오류가 존재하는지 확인하는 값 : 2 byte 

* 출발지의 IP 주소(Source Address) : 4 byte
* 목적지의 IP 주소(Destination Address) : 4 byte
* IP Option 붙을 수도, 안 붙을 수도 있는 선택적인 데이터. (붙는다면 4 byte 씩의 옵션이 붙을 수 있다.) 





#### `3. ICMP 프로토콜`

ICMP (Internet Control Message Protocol), 인터넷 제어 메시지 프로토콜 : 상대방과 통신이 되는지 안되는지 확인하기 위한 프로토콜이다.

네트워크 컴퓨터 위에서 돌아가는 운영체제에서 `오류 메시지`를 전송 받는데 주로 쓰인다.

프로토콜 구조의 Type 과 Code 를 통해 오류 메시지를 전송 받는다.



##### `ICMP 프로토콜의 구조`

총 8 byte (4 byte 씩 2층)

* Type = 대분류. 종류가 굉장히 많다 : 1 byte
  * 0 번 : Echo Reply = 응답
  * 3 번 : Destination Unreachable
  * 5 번 :  Redirect
  * 8 번 : Echo = 요청
  * 11 번 : Time Exceed

* Code = 소분류 : 1 byte
* Checksum = IPv4 의 Checksum 과 같다 : 2 byte

* 그 외 데이터 : 4 byte





### `라우팅 테이블`

3 계층의 대표적인 역할이 최적의 경로를 위의 프로토콜로 찾아가는 일인데, 그 경로를 저장하는 곳이 `라우팅 테이블`이다.

cmd 창에서 `netstat -r`  명령어를 입력하면 볼 수 있다.



#### 다른 네트워크와 통신하는 과정

서로 다른 네트워크에 존재하는 컴퓨터 A 와 B 가 통신한다고 가정해보자.

A 의 네트워크 대역 : 192.168.10.0/24

A 의 IP 주소 : 192.168.10.10

B 의 네트워크 대역 : 192.168.20.0/24

B 의 네트워크 주소 : 192.168.20.20

A 네트워크와 B 네트워크 사이에 두 네트워크가 경로로서 존재한다.

1. A 에서 요청을 보낸다.
2. 이 요청 패킷의 Ethernet 프로토콜의 목적지 주소는 같은 네트워크 대역의 라우터 MAC 주소이다.
3. 스위치 장비가 데이터를 라우터에게 보낸다.
4. 라우터는 받은 데이터의 IPv4 에 적힌 목적지 주소가 자신이 아닌 것을 확인.
5. 라우팅 테이블을 확인해본다.
6. 전달받은 목적지 주소의 대역을 비교해 경로를 확인한다.
7. 경로를 확인 후 Ethernet 프로토콜을 다시 만든다. 목적지 MAC 주소와 출발지 MAC 주소를 라우팅 테이블에서 확인한 경로의 네트워크와 통신할 수 있는 주소로 바꾸어 데이터를 보낸다. (라우터, 즉 공유기는 연결된 두 네트워크의 주소 모두 갖고있다.)
8. 이 데이터를 전달받은 라우터(3계층 장비)는 다시한번 데이터를 분석. 목적지 IP 주소가 자신이 아닌 것을 확인.
9. 또 다시 라우팅 테이블을 확인해 다음 경로를 확인.
10. Ethernet 프로토콜의 출발지, 목적지 MAC 주소를 변경하여 또 데이터 전달
11. 이 데이터를 전달받은 라우터는 데이터를 분석. 목적지 IP 주소가 자신의 네트워크 대역인 것을 확인.
12. 스위치 장비를 통해 해당 MAC 주소(B)로 전달
13. B 컴퓨터는 ICMP 프로토콜에 응답 데이터를 넣어 위와 같은 과정으로 A 에게 응답을 보낸다.





### `IPv4 의 조각화`

큰 IP 패킷들이 적은 `MTU`(Maximum Transmission Unit = 최대 전송 단위)를 갖는 링크를 통하여 전송되려면 여러 개의 작은 패킷으로 `쪼개어/ 조각화 되어` 전송돼야 한다.

즉, 목적지까지 패킷을 전달하는 과정에 통과하는 각 라우터마다 전송에 적합한 프레임으로 변환이 필요하다.

일단 조각화되면, 최종 목적지에 도달할 때까지 재조립되지 않는 것이 일반적이다.

IPv4 에서는 발신지 뿐 아니라 중간 라우터에서도 IP 조각화가 가능



##### `MTU`

* 페이로드와 IPv4(20 byte) 까지 합친 값
* 데이터를 쪼갤 때, 모든 조각 데이터에 IPv4(20 byte)가 붙어야 한다. - IPv4 프로토콜의 구조는 붙은 조각데이터에 따라 달라진다. (데이터의 크기, More Fragment 의 여부, Offset 의 값 등)
* 조각화된 패킷은 모두 20byte 인 IPv4 를 포함해 MTU 를 넘어서는 안된다. 

